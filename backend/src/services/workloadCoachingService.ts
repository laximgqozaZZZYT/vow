/**
 * Workload Coaching Service
 *
 * Provides rule-based coaching for habit workload adjustments.
 * Detects struggling habits and suggests workload reductions or baby steps.
 *
 * Requirements: 10.1, 10.2, 10.3, 10.4, 10.5
 */

import type { SupabaseClient } from '@supabase/supabase-js';
import { getLogger } from '../utils/logger.js';

const logger = getLogger('workloadCoachingService');

/**
 * Coaching configuration constants.
 */
export const COACHING_CONFIG = {
  // Workload adjustment for consecutive failures
  workloadAdjustment: {
    triggerDays: 3,           // 3 consecutive days of failure
    adjustmentRate: 0.5,      // Reduce to 50%
    minValue: 1,              // Minimum target count
  },
  // Baby step for inactive habits
  babyStep: {
    triggerDays: 7,           // 7 days of no activity
    quantityRate: 0.2,        // 20% for quantity-based
    timeRate: 0.1,            // 10% for time-based
    countValue: 1,            // 1 for count-based
    minValue: 1,              // Minimum target count
    timeUnits: ['分', '時間', 'min', 'hour', 'minutes', 'hours'],
  },
  // Recovery after success
  recovery: {
    partialRecoveryDays: 3,   // 3 consecutive successes for partial recovery
    partialRecoveryRate: 0.75, // Recover to 75% of original
    fullRecoveryDays: 5,      // 5 consecutive successes for full recovery
  },
  // Cooldown periods
  cooldown: {
    singleDismissDays: 7,     // 7 days after single dismiss
    tripleDismissDays: 30,    // 30 days after 3 dismisses
    snoozeDays: 1,            // 24 hours for snooze
  },
} as const;

/**
 * Coaching candidate detected by the service.
 */
export interface CoachingCandidate {
  habitId: string;
  habitName: string;
  reason: 'consecutive_miss' | 'no_activity';
  consecutiveMissDays?: number;
  daysSinceCreation?: number;
  last7DaysCompletionRate?: number;
  currentTargetCount: number;
  workloadUnit: string | null;
}

/**
 * Coaching proposal generated by the service.
 */
export interface CoachingProposal {
  id?: string;
  habitId: string;
  habitName: string;
  type: 'workload_adjustment' | 'baby_step' | 'partial_recovery' | 'full_recovery';
  currentTargetCount: number;
  proposedTargetCount: number;
  originalTargetCount?: number;
  workloadUnit: string | null;
  reason: string;
  message: string;
  status: 'pending' | 'accepted' | 'dismissed' | 'snoozed' | 'expired';
  dismissCount: number;
  dismissedUntil?: string;
  snoozedUntil?: string;
  expiresAt: string;
  createdAt: string;
}

/**
 * Recovery proposal for habits that have improved.
 */
export interface RecoveryProposal {
  habitId: string;
  habitName: string;
  type: 'partial_recovery' | 'full_recovery';
  currentTargetCount: number;
  proposedTargetCount: number;
  originalTargetCount: number;
  consecutiveSuccessDays: number;
  message: string;
}

/**
 * Workload Coaching Service.
 */
export class WorkloadCoachingService {
  private readonly supabase: SupabaseClient;

  constructor(supabase: SupabaseClient) {
    this.supabase = supabase;
  }

  /**
   * Check for habits that need coaching.
   *
   * Requirements: 10.1, 10.2
   */
  async checkForCoachingCandidates(userId: string): Promise<CoachingCandidate[]> {
    const candidates: CoachingCandidate[] = [];

    // Get user's active habits
    const { data: habits, error: habitsError } = await this.supabase
      .from('habits')
      .select('id, name, target_count, workload_unit, created_at')
      .eq('owner_id', userId)
      .eq('is_active', true);

    if (habitsError || !habits) {
      logger.error('Failed to fetch habits for coaching check', undefined, { userId });
      return [];
    }

    const today = new Date();
    const todayStr = today.toISOString().slice(0, 10);

    for (const habit of habits) {
      // Check for existing pending proposals
      const { data: existingProposal } = await this.supabase
        .from('coaching_proposals')
        .select('id')
        .eq('habit_id', habit.id)
        .eq('status', 'pending')
        .single();

      if (existingProposal) {
        continue; // Skip if there's already a pending proposal
      }

      // Check for cooldown
      const { data: lastDismissed } = await this.supabase
        .from('coaching_proposals')
        .select('dismissed_until')
        .eq('habit_id', habit.id)
        .eq('status', 'dismissed')
        .order('updated_at', { ascending: false })
        .limit(1)
        .single();

      if (lastDismissed?.dismissed_until && new Date(lastDismissed.dismissed_until) > today) {
        continue; // Still in cooldown
      }

      // Get last 7 days of activities
      const sevenDaysAgo = new Date(today);
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const sevenDaysAgoStr = sevenDaysAgo.toISOString().slice(0, 10);

      const { data: activities } = await this.supabase
        .from('activities')
        .select('date, count')
        .eq('habit_id', habit.id)
        .gte('date', sevenDaysAgoStr)
        .lte('date', todayStr);

      const activityMap = new Map<string, number>();
      for (const activity of activities || []) {
        activityMap.set(activity.date, activity.count);
      }

      // Check for consecutive misses (Requirement 10.1)
      let consecutiveMissDays = 0;
      for (let i = 1; i <= 7; i++) {
        const checkDate = new Date(today);
        checkDate.setDate(checkDate.getDate() - i);
        const checkDateStr = checkDate.toISOString().slice(0, 10);
        const count = activityMap.get(checkDateStr) || 0;

        if (count < habit.target_count) {
          consecutiveMissDays++;
        } else {
          break;
        }
      }

      if (consecutiveMissDays >= COACHING_CONFIG.workloadAdjustment.triggerDays) {
        candidates.push({
          habitId: habit.id,
          habitName: habit.name,
          reason: 'consecutive_miss',
          consecutiveMissDays,
          currentTargetCount: habit.target_count,
          workloadUnit: habit.workload_unit,
        });
        continue;
      }

      // Check for no activity (Requirement 10.2)
      const habitCreatedAt = new Date(habit.created_at);
      const daysSinceCreation = Math.floor((today.getTime() - habitCreatedAt.getTime()) / (1000 * 60 * 60 * 24));

      if (daysSinceCreation >= COACHING_CONFIG.babyStep.triggerDays) {
        const totalActivity = Array.from(activityMap.values()).reduce((sum, count) => sum + count, 0);

        if (totalActivity === 0) {
          candidates.push({
            habitId: habit.id,
            habitName: habit.name,
            reason: 'no_activity',
            daysSinceCreation,
            currentTargetCount: habit.target_count,
            workloadUnit: habit.workload_unit,
          });
        }
      }
    }

    logger.info('Coaching candidates found', { userId, count: candidates.length });
    return candidates;
  }

  /**
   * Generate workload adjustment proposal.
   *
   * Requirement 10.1
   */
  generateWorkloadAdjustment(
    habitId: string,
    habitName: string,
    currentTargetCount: number,
    workloadUnit: string | null,
    consecutiveMissDays: number
  ): CoachingProposal {
    const proposedTargetCount = Math.max(
      COACHING_CONFIG.workloadAdjustment.minValue,
      Math.ceil(currentTargetCount * COACHING_CONFIG.workloadAdjustment.adjustmentRate)
    );

    const unitDisplay = workloadUnit || '回';
    const message = `「${habitName}」が${consecutiveMissDays}日連続で未達成です。目標を${currentTargetCount}${unitDisplay}から${proposedTargetCount}${unitDisplay}に調整しませんか？`;

    return {
      habitId,
      habitName,
      type: 'workload_adjustment',
      currentTargetCount,
      proposedTargetCount,
      workloadUnit,
      reason: `${consecutiveMissDays}日連続未達成`,
      message,
      status: 'pending',
      dismissCount: 0,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      createdAt: new Date().toISOString(),
    };
  }

  /**
   * Generate baby step proposal.
   *
   * Requirement 10.2
   */
  generateBabyStep(
    habitId: string,
    habitName: string,
    currentTargetCount: number,
    workloadUnit: string | null,
    daysSinceCreation: number
  ): CoachingProposal {
    const proposedTargetCount = this.calculateBabyStepTarget(currentTargetCount, workloadUnit);

    const unitDisplay = workloadUnit || '回';
    const message = `「${habitName}」を作成してから${daysSinceCreation}日経ちましたが、まだ記録がありません。まずは${proposedTargetCount}${unitDisplay}から始めてみませんか？`;

    return {
      habitId,
      habitName,
      type: 'baby_step',
      currentTargetCount,
      proposedTargetCount,
      workloadUnit,
      reason: `${daysSinceCreation}日間活動なし`,
      message,
      status: 'pending',
      dismissCount: 0,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      createdAt: new Date().toISOString(),
    };
  }

  /**
   * Calculate baby step target based on workload type.
   */
  private calculateBabyStepTarget(currentTargetCount: number, workloadUnit: string | null): number {
    const config = COACHING_CONFIG.babyStep;

    // Time-based habits
    if (workloadUnit && config.timeUnits.some(u => workloadUnit.includes(u))) {
      return Math.max(config.minValue, Math.ceil(currentTargetCount * config.timeRate));
    }

    // Quantity-based habits (has unit)
    if (workloadUnit) {
      return Math.max(config.minValue, Math.ceil(currentTargetCount * config.quantityRate));
    }

    // Count-based habits (no unit)
    return config.countValue;
  }

  /**
   * Check for recovery opportunity.
   *
   * Requirement 10.5
   */
  async checkForRecoveryOpportunity(userId: string, habitId: string): Promise<RecoveryProposal | null> {
    // Get habit with original target count
    const { data: habit, error: habitError } = await this.supabase
      .from('habits')
      .select('id, name, target_count, original_target_count, workload_unit')
      .eq('id', habitId)
      .eq('owner_id', userId)
      .single();

    if (habitError || !habit || !habit.original_target_count) {
      return null; // No original target count means no adjustment was made
    }

    if (habit.target_count >= habit.original_target_count) {
      return null; // Already at or above original
    }

    // Count consecutive success days
    const today = new Date();

    let consecutiveSuccessDays = 0;
    for (let i = 1; i <= 7; i++) {
      const checkDate = new Date(today);
      checkDate.setDate(checkDate.getDate() - i);
      const checkDateStr = checkDate.toISOString().slice(0, 10);

      const { data: activity } = await this.supabase
        .from('activities')
        .select('count')
        .eq('habit_id', habitId)
        .eq('date', checkDateStr)
        .single();

      if (activity && activity.count >= habit.target_count) {
        consecutiveSuccessDays++;
      } else {
        break;
      }
    }

    const config = COACHING_CONFIG.recovery;
    const unitDisplay = habit.workload_unit || '回';

    // Full recovery (5 consecutive days)
    if (consecutiveSuccessDays >= config.fullRecoveryDays) {
      return {
        habitId: habit.id,
        habitName: habit.name,
        type: 'full_recovery',
        currentTargetCount: habit.target_count,
        proposedTargetCount: habit.original_target_count,
        originalTargetCount: habit.original_target_count,
        consecutiveSuccessDays,
        message: `素晴らしい！「${habit.name}」を${consecutiveSuccessDays}日連続で達成しました。元の目標${habit.original_target_count}${unitDisplay}に戻しませんか？`,
      };
    }

    // Partial recovery (3 consecutive days)
    if (consecutiveSuccessDays >= config.partialRecoveryDays) {
      const partialTarget = Math.ceil(habit.original_target_count * config.partialRecoveryRate);

      if (partialTarget > habit.target_count) {
        return {
          habitId: habit.id,
          habitName: habit.name,
          type: 'partial_recovery',
          currentTargetCount: habit.target_count,
          proposedTargetCount: partialTarget,
          originalTargetCount: habit.original_target_count,
          consecutiveSuccessDays,
          message: `順調です！「${habit.name}」を${consecutiveSuccessDays}日連続で達成しました。目標を${partialTarget}${unitDisplay}に上げてみませんか？`,
        };
      }
    }

    return null;
  }

  /**
   * Apply a coaching proposal.
   *
   * Requirement 10.3
   */
  async applyProposal(userId: string, proposalId: string): Promise<void> {
    // Get proposal
    const { data: proposal, error: proposalError } = await this.supabase
      .from('coaching_proposals')
      .select('*')
      .eq('id', proposalId)
      .eq('user_id', userId)
      .eq('status', 'pending')
      .single();

    if (proposalError || !proposal) {
      throw new Error('Proposal not found or already processed');
    }

    // Get current habit
    const { data: habit, error: habitError } = await this.supabase
      .from('habits')
      .select('target_count, original_target_count')
      .eq('id', proposal.habit_id)
      .single();

    if (habitError || !habit) {
      throw new Error('Habit not found');
    }

    // Store original target count if this is the first adjustment
    const originalTargetCount = habit.original_target_count || habit.target_count;

    // Update habit
    const { error: updateError } = await this.supabase
      .from('habits')
      .update({
        target_count: proposal.proposed_target_count,
        original_target_count: originalTargetCount,
        updated_at: new Date().toISOString(),
      })
      .eq('id', proposal.habit_id);

    if (updateError) {
      throw new Error('Failed to update habit');
    }

    // Update proposal status
    await this.supabase
      .from('coaching_proposals')
      .update({
        status: 'accepted',
        updated_at: new Date().toISOString(),
      })
      .eq('id', proposalId);

    // Record history
    await this.supabase
      .from('workload_coaching_history')
      .insert({
        user_id: userId,
        habit_id: proposal.habit_id,
        proposal_id: proposalId,
        action: `${proposal.type}_applied`,
        previous_target_count: habit.target_count,
        new_target_count: proposal.proposed_target_count,
      });

    logger.info('Coaching proposal applied', {
      userId,
      proposalId,
      habitId: proposal.habit_id,
      type: proposal.type,
    });
  }

  /**
   * Dismiss a coaching proposal.
   *
   * Requirement 10.3
   */
  async dismissProposal(userId: string, proposalId: string): Promise<void> {
    // Get proposal
    const { data: proposal, error: proposalError } = await this.supabase
      .from('coaching_proposals')
      .select('*')
      .eq('id', proposalId)
      .eq('user_id', userId)
      .eq('status', 'pending')
      .single();

    if (proposalError || !proposal) {
      throw new Error('Proposal not found or already processed');
    }

    const newDismissCount = proposal.dismiss_count + 1;
    const cooldownDays = newDismissCount >= 3
      ? COACHING_CONFIG.cooldown.tripleDismissDays
      : COACHING_CONFIG.cooldown.singleDismissDays;

    const dismissedUntil = new Date(Date.now() + cooldownDays * 24 * 60 * 60 * 1000).toISOString();

    // Update proposal
    await this.supabase
      .from('coaching_proposals')
      .update({
        status: 'dismissed',
        dismiss_count: newDismissCount,
        dismissed_until: dismissedUntil,
        updated_at: new Date().toISOString(),
      })
      .eq('id', proposalId);

    // Record history
    await this.supabase
      .from('workload_coaching_history')
      .insert({
        user_id: userId,
        habit_id: proposal.habit_id,
        proposal_id: proposalId,
        action: 'dismissed',
        previous_target_count: proposal.current_target_count,
        new_target_count: null,
      });

    logger.info('Coaching proposal dismissed', {
      userId,
      proposalId,
      dismissCount: newDismissCount,
      cooldownDays,
    });
  }

  /**
   * Snooze a coaching proposal.
   *
   * Requirement 10.4
   */
  async snoozeProposal(userId: string, proposalId: string): Promise<void> {
    // Get proposal
    const { data: proposal, error: proposalError } = await this.supabase
      .from('coaching_proposals')
      .select('*')
      .eq('id', proposalId)
      .eq('user_id', userId)
      .eq('status', 'pending')
      .single();

    if (proposalError || !proposal) {
      throw new Error('Proposal not found or already processed');
    }

    const snoozedUntil = new Date(Date.now() + COACHING_CONFIG.cooldown.snoozeDays * 24 * 60 * 60 * 1000).toISOString();

    // Update proposal
    await this.supabase
      .from('coaching_proposals')
      .update({
        status: 'snoozed',
        snoozed_until: snoozedUntil,
        updated_at: new Date().toISOString(),
      })
      .eq('id', proposalId);

    // Record history
    await this.supabase
      .from('workload_coaching_history')
      .insert({
        user_id: userId,
        habit_id: proposal.habit_id,
        proposal_id: proposalId,
        action: 'snoozed',
        previous_target_count: proposal.current_target_count,
        new_target_count: null,
      });

    logger.info('Coaching proposal snoozed', { userId, proposalId });
  }

  /**
   * Get pending proposals for a user.
   */
  async getPendingProposals(userId: string): Promise<CoachingProposal[]> {
    const now = new Date().toISOString();

    const { data, error } = await this.supabase
      .from('coaching_proposals')
      .select('*')
      .eq('user_id', userId)
      .eq('status', 'pending')
      .gt('expires_at', now)
      .order('created_at', { ascending: false });

    if (error) {
      logger.error('Failed to fetch pending proposals', undefined, { userId });
      return [];
    }

    return (data || []).map(p => ({
      id: p.id,
      habitId: p.habit_id,
      habitName: '', // Will be populated by caller if needed
      type: p.type,
      currentTargetCount: p.current_target_count,
      proposedTargetCount: p.proposed_target_count,
      originalTargetCount: p.original_target_count,
      workloadUnit: p.workload_unit,
      reason: p.reason,
      message: p.message,
      status: p.status,
      dismissCount: p.dismiss_count,
      dismissedUntil: p.dismissed_until,
      snoozedUntil: p.snoozed_until,
      expiresAt: p.expires_at,
      createdAt: p.created_at,
    }));
  }

  /**
   * Create and save a coaching proposal.
   */
  async createProposal(userId: string, proposal: CoachingProposal): Promise<string> {
    const { data, error } = await this.supabase
      .from('coaching_proposals')
      .insert({
        user_id: userId,
        habit_id: proposal.habitId,
        type: proposal.type,
        current_target_count: proposal.currentTargetCount,
        proposed_target_count: proposal.proposedTargetCount,
        original_target_count: proposal.originalTargetCount,
        workload_unit: proposal.workloadUnit,
        reason: proposal.reason,
        message: proposal.message,
        status: proposal.status,
        dismiss_count: proposal.dismissCount,
        expires_at: proposal.expiresAt,
      })
      .select('id')
      .single();

    if (error || !data) {
      throw new Error('Failed to create proposal');
    }

    logger.info('Coaching proposal created', {
      userId,
      proposalId: data.id,
      habitId: proposal.habitId,
      type: proposal.type,
    });

    return data.id;
  }
}

// Singleton instance
let _workloadCoachingService: WorkloadCoachingService | null = null;

/**
 * Get or create the singleton workload coaching service instance.
 */
export function getWorkloadCoachingService(supabase: SupabaseClient): WorkloadCoachingService {
  if (_workloadCoachingService === null) {
    _workloadCoachingService = new WorkloadCoachingService(supabase);
  }
  return _workloadCoachingService;
}

/**
 * Reset the singleton instance (useful for testing).
 */
export function resetWorkloadCoachingService(): void {
  _workloadCoachingService = null;
}
